
3KPirate_attiny.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  0000088e  00000922  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000088e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000031  00800104  00800104  00000926  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000926  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000d0  00000000  00000000  00000956  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000c44  00000000  00000000  00000a26  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000005f8  00000000  00000000  0000166a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000063d  00000000  00000000  00001c62  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000021c  00000000  00000000  000022a0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000596  00000000  00000000  000024bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000448  00000000  00000000  00002a52  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000a0  00000000  00000000  00002e9a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	2d c0       	rjmp	.+90     	; 0x5c <__ctors_end>
   2:	47 c0       	rjmp	.+142    	; 0x92 <__bad_interrupt>
   4:	46 c0       	rjmp	.+140    	; 0x92 <__bad_interrupt>
   6:	45 c0       	rjmp	.+138    	; 0x92 <__bad_interrupt>
   8:	44 c0       	rjmp	.+136    	; 0x92 <__bad_interrupt>
   a:	43 c0       	rjmp	.+134    	; 0x92 <__bad_interrupt>
   c:	42 c0       	rjmp	.+132    	; 0x92 <__bad_interrupt>
   e:	41 c0       	rjmp	.+130    	; 0x92 <__bad_interrupt>
  10:	40 c0       	rjmp	.+128    	; 0x92 <__bad_interrupt>
  12:	3f c0       	rjmp	.+126    	; 0x92 <__bad_interrupt>
  14:	3e c0       	rjmp	.+124    	; 0x92 <__bad_interrupt>
  16:	3d c0       	rjmp	.+122    	; 0x92 <__bad_interrupt>
  18:	2b c3       	rjmp	.+1622   	; 0x670 <__vector_12>
  1a:	3b c0       	rjmp	.+118    	; 0x92 <__bad_interrupt>
  1c:	3a c0       	rjmp	.+116    	; 0x92 <__bad_interrupt>
  1e:	39 c0       	rjmp	.+114    	; 0x92 <__bad_interrupt>
  20:	87 c0       	rjmp	.+270    	; 0x130 <__vector_16>
  22:	37 c0       	rjmp	.+110    	; 0x92 <__bad_interrupt>
  24:	36 c0       	rjmp	.+108    	; 0x92 <__bad_interrupt>
  26:	96 c3       	rjmp	.+1836   	; 0x754 <__vector_19>
  28:	1a c2       	rjmp	.+1076   	; 0x45e <pirate_process_cmd+0xe2>
  2a:	b2 c1       	rjmp	.+868    	; 0x390 <pirate_process_cmd+0x14>
  2c:	bc c1       	rjmp	.+888    	; 0x3a6 <pirate_process_cmd+0x2a>
  2e:	cd c1       	rjmp	.+922    	; 0x3ca <pirate_process_cmd+0x4e>
  30:	ea c1       	rjmp	.+980    	; 0x406 <pirate_process_cmd+0x8a>
  32:	15 c2       	rjmp	.+1066   	; 0x45e <pirate_process_cmd+0xe2>
  34:	18 c2       	rjmp	.+1072   	; 0x466 <pirate_process_cmd+0xea>
  36:	17 c2       	rjmp	.+1070   	; 0x466 <pirate_process_cmd+0xea>
  38:	eb c1       	rjmp	.+982    	; 0x410 <pirate_process_cmd+0x94>
  3a:	f3 c1       	rjmp	.+998    	; 0x422 <pirate_process_cmd+0xa6>
  3c:	14 c2       	rjmp	.+1064   	; 0x466 <pirate_process_cmd+0xea>
  3e:	13 c2       	rjmp	.+1062   	; 0x466 <pirate_process_cmd+0xea>
  40:	12 c2       	rjmp	.+1060   	; 0x466 <pirate_process_cmd+0xea>
  42:	11 c2       	rjmp	.+1058   	; 0x466 <pirate_process_cmd+0xea>
  44:	10 c2       	rjmp	.+1056   	; 0x466 <pirate_process_cmd+0xea>
  46:	fb c1       	rjmp	.+1014   	; 0x43e <pirate_process_cmd+0xc2>
  48:	0a c2       	rjmp	.+1044   	; 0x45e <pirate_process_cmd+0xe2>
  4a:	09 c2       	rjmp	.+1042   	; 0x45e <pirate_process_cmd+0xe2>
  4c:	0c c2       	rjmp	.+1048   	; 0x466 <pirate_process_cmd+0xea>
  4e:	0b c2       	rjmp	.+1046   	; 0x466 <pirate_process_cmd+0xea>
  50:	0a c2       	rjmp	.+1044   	; 0x466 <pirate_process_cmd+0xea>
  52:	09 c2       	rjmp	.+1042   	; 0x466 <pirate_process_cmd+0xea>
  54:	08 c2       	rjmp	.+1040   	; 0x466 <pirate_process_cmd+0xea>
  56:	07 c2       	rjmp	.+1038   	; 0x466 <pirate_process_cmd+0xea>
  58:	06 c2       	rjmp	.+1036   	; 0x466 <pirate_process_cmd+0xea>
  5a:	f5 c1       	rjmp	.+1002   	; 0x446 <pirate_process_cmd+0xca>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d2 e0       	ldi	r29, 0x02	; 2
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_copy_data>:
  68:	11 e0       	ldi	r17, 0x01	; 1
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	b1 e0       	ldi	r27, 0x01	; 1
  6e:	ee e8       	ldi	r30, 0x8E	; 142
  70:	f8 e0       	ldi	r31, 0x08	; 8
  72:	02 c0       	rjmp	.+4      	; 0x78 <__do_copy_data+0x10>
  74:	05 90       	lpm	r0, Z+
  76:	0d 92       	st	X+, r0
  78:	a4 30       	cpi	r26, 0x04	; 4
  7a:	b1 07       	cpc	r27, r17
  7c:	d9 f7       	brne	.-10     	; 0x74 <__do_copy_data+0xc>

0000007e <__do_clear_bss>:
  7e:	21 e0       	ldi	r18, 0x01	; 1
  80:	a4 e0       	ldi	r26, 0x04	; 4
  82:	b1 e0       	ldi	r27, 0x01	; 1
  84:	01 c0       	rjmp	.+2      	; 0x88 <.do_clear_bss_start>

00000086 <.do_clear_bss_loop>:
  86:	1d 92       	st	X+, r1

00000088 <.do_clear_bss_start>:
  88:	a5 33       	cpi	r26, 0x35	; 53
  8a:	b2 07       	cpc	r27, r18
  8c:	e1 f7       	brne	.-8      	; 0x86 <.do_clear_bss_loop>
  8e:	5d d2       	rcall	.+1210   	; 0x54a <main>
  90:	fc c3       	rjmp	.+2040   	; 0x88a <_exit>

00000092 <__bad_interrupt>:
  92:	b6 cf       	rjmp	.-148    	; 0x0 <__vectors>

00000094 <adc_init>:
  94:	e4 e6       	ldi	r30, 0x64	; 100
  96:	f0 e0       	ldi	r31, 0x00	; 0
  98:	80 81       	ld	r24, Z
  9a:	8e 7f       	andi	r24, 0xFE	; 254
  9c:	80 83       	st	Z, r24
  9e:	ea e7       	ldi	r30, 0x7A	; 122
  a0:	f0 e0       	ldi	r31, 0x00	; 0
  a2:	8f ed       	ldi	r24, 0xDF	; 223
  a4:	80 83       	st	Z, r24
  a6:	ac e7       	ldi	r26, 0x7C	; 124
  a8:	b0 e0       	ldi	r27, 0x00	; 0
  aa:	8c 91       	ld	r24, X
  ac:	8f 7d       	andi	r24, 0xDF	; 223
  ae:	8c 93       	st	X, r24
  b0:	80 81       	ld	r24, Z
  b2:	88 68       	ori	r24, 0x88	; 136
  b4:	80 83       	st	Z, r24
  b6:	08 95       	ret

000000b8 <adc_channel>:
  b8:	80 31       	cpi	r24, 0x10	; 16
  ba:	90 f4       	brcc	.+36     	; 0xe0 <adc_channel+0x28>
  bc:	90 91 7c 00 	lds	r25, 0x007C
  c0:	90 7f       	andi	r25, 0xF0	; 240
  c2:	98 2b       	or	r25, r24
  c4:	90 93 7c 00 	sts	0x007C, r25
  c8:	88 30       	cpi	r24, 0x08	; 8
  ca:	38 f4       	brcc	.+14     	; 0xda <adc_channel+0x22>
  cc:	91 e0       	ldi	r25, 0x01	; 1
  ce:	01 c0       	rjmp	.+2      	; 0xd2 <adc_channel+0x1a>
  d0:	99 0f       	add	r25, r25
  d2:	8a 95       	dec	r24
  d4:	ea f7       	brpl	.-6      	; 0xd0 <adc_channel+0x18>
  d6:	89 2f       	mov	r24, r25
  d8:	01 c0       	rjmp	.+2      	; 0xdc <adc_channel+0x24>
  da:	80 e0       	ldi	r24, 0x00	; 0
  dc:	80 93 7e 00 	sts	0x007E, r24
  e0:	61 30       	cpi	r22, 0x01	; 1
  e2:	21 f4       	brne	.+8      	; 0xec <adc_channel+0x34>
  e4:	80 91 7c 00 	lds	r24, 0x007C
  e8:	80 64       	ori	r24, 0x40	; 64
  ea:	05 c0       	rjmp	.+10     	; 0xf6 <adc_channel+0x3e>
  ec:	62 30       	cpi	r22, 0x02	; 2
  ee:	29 f4       	brne	.+10     	; 0xfa <adc_channel+0x42>
  f0:	80 91 7c 00 	lds	r24, 0x007C
  f4:	8f 7b       	andi	r24, 0xBF	; 191
  f6:	80 93 7c 00 	sts	0x007C, r24
  fa:	08 95       	ret

000000fc <adc_start>:
  fc:	90 91 7a 00 	lds	r25, 0x007A
 100:	96 fd       	sbrc	r25, 6
 102:	14 c0       	rjmp	.+40     	; 0x12c <adc_start+0x30>
 104:	80 93 0d 01 	sts	0x010D, r24
 108:	61 11       	cpse	r22, r1
 10a:	01 c0       	rjmp	.+2      	; 0x10e <adc_start+0x12>
 10c:	80 e0       	ldi	r24, 0x00	; 0
 10e:	80 93 04 01 	sts	0x0104, r24
 112:	80 91 7c 00 	lds	r24, 0x007C
 116:	8f 70       	andi	r24, 0x0F	; 15
 118:	80 68       	ori	r24, 0x80	; 128
 11a:	80 93 20 01 	sts	0x0120, r24
 11e:	80 91 7a 00 	lds	r24, 0x007A
 122:	80 64       	ori	r24, 0x40	; 64
 124:	80 93 7a 00 	sts	0x007A, r24
 128:	80 e0       	ldi	r24, 0x00	; 0
 12a:	08 95       	ret
 12c:	81 e0       	ldi	r24, 0x01	; 1
 12e:	08 95       	ret

00000130 <__vector_16>:
 130:	1f 92       	push	r1
 132:	0f 92       	push	r0
 134:	0f b6       	in	r0, 0x3f	; 63
 136:	0f 92       	push	r0
 138:	11 24       	eor	r1, r1
 13a:	2f 93       	push	r18
 13c:	3f 93       	push	r19
 13e:	4f 93       	push	r20
 140:	5f 93       	push	r21
 142:	8f 93       	push	r24
 144:	9f 93       	push	r25
 146:	ef 93       	push	r30
 148:	ff 93       	push	r31
 14a:	40 91 7c 00 	lds	r20, 0x007C
 14e:	4f 70       	andi	r20, 0x0F	; 15
 150:	50 91 04 01 	lds	r21, 0x0104
 154:	55 23       	and	r21, r21
 156:	c1 f0       	breq	.+48     	; 0x188 <__vector_16+0x58>
 158:	80 91 0d 01 	lds	r24, 0x010D
 15c:	58 17       	cp	r21, r24
 15e:	a1 f0       	breq	.+40     	; 0x188 <__vector_16+0x58>
 160:	49 30       	cpi	r20, 0x09	; 9
 162:	90 f4       	brcc	.+36     	; 0x188 <__vector_16+0x58>
 164:	e4 2f       	mov	r30, r20
 166:	f0 e0       	ldi	r31, 0x00	; 0
 168:	ee 0f       	add	r30, r30
 16a:	ff 1f       	adc	r31, r31
 16c:	e2 5f       	subi	r30, 0xF2	; 242
 16e:	fe 4f       	sbci	r31, 0xFE	; 254
 170:	80 81       	ld	r24, Z
 172:	91 81       	ldd	r25, Z+1	; 0x01
 174:	20 91 78 00 	lds	r18, 0x0078
 178:	30 91 79 00 	lds	r19, 0x0079
 17c:	82 0f       	add	r24, r18
 17e:	93 1f       	adc	r25, r19
 180:	96 95       	lsr	r25
 182:	87 95       	ror	r24
 184:	91 83       	std	Z+1, r25	; 0x01
 186:	80 83       	st	Z, r24
 188:	80 91 0d 01 	lds	r24, 0x010D
 18c:	88 23       	and	r24, r24
 18e:	59 f0       	breq	.+22     	; 0x1a6 <__vector_16+0x76>
 190:	80 91 0d 01 	lds	r24, 0x010D
 194:	81 50       	subi	r24, 0x01	; 1
 196:	80 93 0d 01 	sts	0x010D, r24
 19a:	80 91 7a 00 	lds	r24, 0x007A
 19e:	80 64       	ori	r24, 0x40	; 64
 1a0:	80 93 7a 00 	sts	0x007A, r24
 1a4:	12 c0       	rjmp	.+36     	; 0x1ca <__vector_16+0x9a>
 1a6:	51 11       	cpse	r21, r1
 1a8:	0e c0       	rjmp	.+28     	; 0x1c6 <__vector_16+0x96>
 1aa:	49 30       	cpi	r20, 0x09	; 9
 1ac:	60 f4       	brcc	.+24     	; 0x1c6 <__vector_16+0x96>
 1ae:	e4 2f       	mov	r30, r20
 1b0:	f0 e0       	ldi	r31, 0x00	; 0
 1b2:	80 91 78 00 	lds	r24, 0x0078
 1b6:	90 91 79 00 	lds	r25, 0x0079
 1ba:	ee 0f       	add	r30, r30
 1bc:	ff 1f       	adc	r31, r31
 1be:	e2 5f       	subi	r30, 0xF2	; 242
 1c0:	fe 4f       	sbci	r31, 0xFE	; 254
 1c2:	91 83       	std	Z+1, r25	; 0x01
 1c4:	80 83       	st	Z, r24
 1c6:	10 92 20 01 	sts	0x0120, r1
 1ca:	ff 91       	pop	r31
 1cc:	ef 91       	pop	r30
 1ce:	9f 91       	pop	r25
 1d0:	8f 91       	pop	r24
 1d2:	5f 91       	pop	r21
 1d4:	4f 91       	pop	r20
 1d6:	3f 91       	pop	r19
 1d8:	2f 91       	pop	r18
 1da:	0f 90       	pop	r0
 1dc:	0f be       	out	0x3f, r0	; 63
 1de:	0f 90       	pop	r0
 1e0:	1f 90       	pop	r1
 1e2:	18 95       	reti

000001e4 <rgbled_io_init>:
 1e4:	8a b1       	in	r24, 0x0a	; 10
 1e6:	80 6f       	ori	r24, 0xF0	; 240
 1e8:	8a b9       	out	0x0a, r24	; 10
 1ea:	87 b1       	in	r24, 0x07	; 7
 1ec:	8f 60       	ori	r24, 0x0F	; 15
 1ee:	87 b9       	out	0x07, r24	; 7
 1f0:	8b b1       	in	r24, 0x0b	; 11
 1f2:	80 6f       	ori	r24, 0xF0	; 240
 1f4:	8b b9       	out	0x0b, r24	; 11
 1f6:	88 b1       	in	r24, 0x08	; 8
 1f8:	8f 60       	ori	r24, 0x0F	; 15
 1fa:	88 b9       	out	0x08, r24	; 8
 1fc:	08 95       	ret

000001fe <rgbled_update>:
 1fe:	cf 93       	push	r28
 200:	df 93       	push	r29
 202:	8b b1       	in	r24, 0x0b	; 11
 204:	80 6f       	ori	r24, 0xF0	; 240
 206:	8b b9       	out	0x0b, r24	; 11
 208:	88 b1       	in	r24, 0x08	; 8
 20a:	8f 60       	ori	r24, 0x0F	; 15
 20c:	88 b9       	out	0x08, r24	; 8
 20e:	c8 e8       	ldi	r28, 0x88	; 136
 210:	d0 e0       	ldi	r29, 0x00	; 0
 212:	8e ef       	ldi	r24, 0xFE	; 254
 214:	88 83       	st	Y, r24
 216:	aa e8       	ldi	r26, 0x8A	; 138
 218:	b0 e0       	ldi	r27, 0x00	; 0
 21a:	8c 93       	st	X, r24
 21c:	8a ef       	ldi	r24, 0xFA	; 250
 21e:	90 e0       	ldi	r25, 0x00	; 0
 220:	90 93 85 00 	sts	0x0085, r25
 224:	80 93 84 00 	sts	0x0084, r24
 228:	4b b1       	in	r20, 0x0b	; 11
 22a:	24 e0       	ldi	r18, 0x04	; 4
 22c:	2d 0d       	add	r18, r13
 22e:	81 e0       	ldi	r24, 0x01	; 1
 230:	90 e0       	ldi	r25, 0x00	; 0
 232:	bc 01       	movw	r22, r24
 234:	02 c0       	rjmp	.+4      	; 0x23a <rgbled_update+0x3c>
 236:	66 0f       	add	r22, r22
 238:	77 1f       	adc	r23, r23
 23a:	2a 95       	dec	r18
 23c:	e2 f7       	brpl	.-8      	; 0x236 <rgbled_update+0x38>
 23e:	9b 01       	movw	r18, r22
 240:	20 95       	com	r18
 242:	24 23       	and	r18, r20
 244:	2b b9       	out	0x0b, r18	; 11
 246:	28 b1       	in	r18, 0x08	; 8
 248:	0d 2c       	mov	r0, r13
 24a:	01 c0       	rjmp	.+2      	; 0x24e <rgbled_update+0x50>
 24c:	88 0f       	add	r24, r24
 24e:	0a 94       	dec	r0
 250:	ea f7       	brpl	.-6      	; 0x24c <rgbled_update+0x4e>
 252:	80 95       	com	r24
 254:	82 23       	and	r24, r18
 256:	88 b9       	out	0x08, r24	; 8
 258:	ed 2d       	mov	r30, r13
 25a:	f0 e0       	ldi	r31, 0x00	; 0
 25c:	ea 5d       	subi	r30, 0xDA	; 218
 25e:	fe 4f       	sbci	r31, 0xFE	; 254
 260:	8b ef       	ldi	r24, 0xFB	; 251
 262:	90 81       	ld	r25, Z
 264:	78 2f       	mov	r23, r24
 266:	79 1b       	sub	r23, r25
 268:	78 83       	st	Y, r23
 26a:	ed 2d       	mov	r30, r13
 26c:	f0 e0       	ldi	r31, 0x00	; 0
 26e:	ee 5d       	subi	r30, 0xDE	; 222
 270:	fe 4f       	sbci	r31, 0xFE	; 254
 272:	90 81       	ld	r25, Z
 274:	89 1b       	sub	r24, r25
 276:	8c 93       	st	X, r24
 278:	df 91       	pop	r29
 27a:	cf 91       	pop	r28
 27c:	08 95       	ret

0000027e <rgbled_sensor_init>:
 27e:	9b b1       	in	r25, 0x0b	; 11
 280:	90 6f       	ori	r25, 0xF0	; 240
 282:	9b b9       	out	0x0b, r25	; 11
 284:	e0 e8       	ldi	r30, 0x80	; 128
 286:	f0 e0       	ldi	r31, 0x00	; 0
 288:	90 81       	ld	r25, Z
 28a:	9f 70       	andi	r25, 0x0F	; 15
 28c:	90 83       	st	Z, r25
 28e:	97 b1       	in	r25, 0x07	; 7
 290:	90 7f       	andi	r25, 0xF0	; 240
 292:	97 b9       	out	0x07, r25	; 7
 294:	95 b7       	in	r25, 0x35	; 53
 296:	90 61       	ori	r25, 0x10	; 16
 298:	95 bf       	out	0x35, r25	; 53
 29a:	97 b1       	in	r25, 0x07	; 7
 29c:	21 e0       	ldi	r18, 0x01	; 1
 29e:	30 e0       	ldi	r19, 0x00	; 0
 2a0:	01 c0       	rjmp	.+2      	; 0x2a4 <rgbled_sensor_init+0x26>
 2a2:	22 0f       	add	r18, r18
 2a4:	8a 95       	dec	r24
 2a6:	ea f7       	brpl	.-6      	; 0x2a2 <rgbled_sensor_init+0x24>
 2a8:	92 2b       	or	r25, r18
 2aa:	97 b9       	out	0x07, r25	; 7
 2ac:	88 b1       	in	r24, 0x08	; 8
 2ae:	80 7f       	andi	r24, 0xF0	; 240
 2b0:	88 b9       	out	0x08, r24	; 8
 2b2:	2a 9a       	sbi	0x05, 2	; 5
 2b4:	88 b1       	in	r24, 0x08	; 8
 2b6:	82 2b       	or	r24, r18
 2b8:	88 b9       	out	0x08, r24	; 8
 2ba:	2a 98       	cbi	0x05, 2	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2bc:	88 e0       	ldi	r24, 0x08	; 8
 2be:	8a 95       	dec	r24
 2c0:	f1 f7       	brne	.-4      	; 0x2be <rgbled_sensor_init+0x40>
 2c2:	87 b1       	in	r24, 0x07	; 7
 2c4:	20 95       	com	r18
 2c6:	82 23       	and	r24, r18
 2c8:	87 b9       	out	0x07, r24	; 7
 2ca:	88 b1       	in	r24, 0x08	; 8
 2cc:	82 23       	and	r24, r18
 2ce:	88 b9       	out	0x08, r24	; 8
 2d0:	85 b7       	in	r24, 0x35	; 53
 2d2:	8f 7e       	andi	r24, 0xEF	; 239
 2d4:	85 bf       	out	0x35, r24	; 53
 2d6:	08 95       	ret

000002d8 <rgbled_sensor_sensitivity>:
 2d8:	84 30       	cpi	r24, 0x04	; 4
 2da:	38 f4       	brcc	.+14     	; 0x2ea <rgbled_sensor_sensitivity+0x12>
 2dc:	66 23       	and	r22, r22
 2de:	29 f0       	breq	.+10     	; 0x2ea <rgbled_sensor_sensitivity+0x12>
 2e0:	e8 2f       	mov	r30, r24
 2e2:	f0 e0       	ldi	r31, 0x00	; 0
 2e4:	e0 50       	subi	r30, 0x00	; 0
 2e6:	ff 4f       	sbci	r31, 0xFF	; 255
 2e8:	60 83       	st	Z, r22
 2ea:	08 95       	ret

000002ec <rgbled_sensor_read_idx>:
 2ec:	83 70       	andi	r24, 0x03	; 3
 2ee:	80 93 05 01 	sts	0x0105, r24
 2f2:	08 95       	ret

000002f4 <rgbled_sensor_read>:
 2f4:	80 91 05 01 	lds	r24, 0x0105
 2f8:	e8 2f       	mov	r30, r24
 2fa:	f0 e0       	ldi	r31, 0x00	; 0
 2fc:	e0 50       	subi	r30, 0x00	; 0
 2fe:	ff 4f       	sbci	r31, 0xFF	; 255
 300:	90 81       	ld	r25, Z
 302:	91 11       	cpse	r25, r1
 304:	01 c0       	rjmp	.+2      	; 0x308 <__stack+0x9>
 306:	91 e0       	ldi	r25, 0x01	; 1
 308:	4e 2d       	mov	r20, r14
 30a:	e1 10       	cpse	r14, r1
 30c:	03 c0       	rjmp	.+6      	; 0x314 <__stack+0x15>
 30e:	61 e0       	ldi	r22, 0x01	; 1
 310:	8f e0       	ldi	r24, 0x0F	; 15
 312:	12 c0       	rjmp	.+36     	; 0x338 <__stack+0x39>
 314:	41 30       	cpi	r20, 0x01	; 1
 316:	19 f4       	brne	.+6      	; 0x31e <__stack+0x1f>
 318:	60 e0       	ldi	r22, 0x00	; 0
 31a:	80 e0       	ldi	r24, 0x00	; 0
 31c:	18 c0       	rjmp	.+48     	; 0x34e <__stack+0x4f>
 31e:	42 30       	cpi	r20, 0x02	; 2
 320:	61 f4       	brne	.+24     	; 0x33a <__stack+0x3b>
 322:	90 91 20 01 	lds	r25, 0x0120
 326:	99 23       	and	r25, r25
 328:	19 f0       	breq	.+6      	; 0x330 <__stack+0x31>
 32a:	ee 24       	eor	r14, r14
 32c:	e3 94       	inc	r14
 32e:	08 95       	ret
 330:	a6 df       	rcall	.-180    	; 0x27e <rgbled_sensor_init>
 332:	6f ef       	ldi	r22, 0xFF	; 255
 334:	80 91 05 01 	lds	r24, 0x0105
 338:	bf ce       	rjmp	.-642    	; 0xb8 <adc_channel>
 33a:	2e 2d       	mov	r18, r14
 33c:	30 e0       	ldi	r19, 0x00	; 0
 33e:	89 2f       	mov	r24, r25
 340:	90 e0       	ldi	r25, 0x00	; 0
 342:	02 96       	adiw	r24, 0x02	; 2
 344:	28 17       	cp	r18, r24
 346:	39 07       	cpc	r19, r25
 348:	19 f4       	brne	.+6      	; 0x350 <__stack+0x51>
 34a:	61 e0       	ldi	r22, 0x01	; 1
 34c:	83 e0       	ldi	r24, 0x03	; 3
 34e:	d6 ce       	rjmp	.-596    	; 0xfc <adc_start>
 350:	82 17       	cp	r24, r18
 352:	93 07       	cpc	r25, r19
 354:	94 f4       	brge	.+36     	; 0x37a <__stack+0x7b>
 356:	41 50       	subi	r20, 0x01	; 1
 358:	e4 2e       	mov	r14, r20
 35a:	80 91 20 01 	lds	r24, 0x0120
 35e:	81 11       	cpse	r24, r1
 360:	0c c0       	rjmp	.+24     	; 0x37a <__stack+0x7b>
 362:	6f ef       	ldi	r22, 0xFF	; 255
 364:	8f e0       	ldi	r24, 0x0F	; 15
 366:	a8 de       	rcall	.-688    	; 0xb8 <adc_channel>
 368:	3d df       	rcall	.-390    	; 0x1e4 <rgbled_io_init>
 36a:	8e ef       	ldi	r24, 0xFE	; 254
 36c:	80 93 80 00 	sts	0x0080, r24
 370:	84 b1       	in	r24, 0x04	; 4
 372:	86 60       	ori	r24, 0x06	; 6
 374:	84 b9       	out	0x04, r24	; 4
 376:	10 92 21 01 	sts	0x0121, r1
 37a:	08 95       	ret

0000037c <pirate_process_cmd>:
	return 0;
}

static uint8_t pirate_process_cmd()
{
	switch (comm_cmd) {
 37c:	8f 2d       	mov	r24, r15
 37e:	90 e0       	ldi	r25, 0x00	; 0
 380:	8a 31       	cpi	r24, 0x1A	; 26
 382:	91 05       	cpc	r25, r1
 384:	08 f0       	brcs	.+2      	; 0x388 <pirate_process_cmd+0xc>
 386:	6f c0       	rjmp	.+222    	; 0x466 <pirate_process_cmd+0xea>
 388:	fc 01       	movw	r30, r24
 38a:	ec 5e       	subi	r30, 0xEC	; 236
 38c:	ff 4f       	sbci	r31, 0xFF	; 255
 38e:	09 94       	ijmp
			break;
		}
		
		// standard commands
		case MODE_EXT_CMD: {		// used for more commands
			if (comm_data_idx >= 1) {
 390:	80 91 34 01 	lds	r24, 0x0134
 394:	88 23       	and	r24, r24
 396:	09 f4       	brne	.+2      	; 0x39a <pirate_process_cmd+0x1e>
 398:	6b c0       	rjmp	.+214    	; 0x470 <pirate_process_cmd+0xf4>
				comm_cmd = comm_data[1];
 39a:	f0 90 31 01 	lds	r15, 0x0131
				// set data index to last (will be reset on next data sent)
				// and also reset timeout since this is effectively a new command
				comm_data_idx = COMM_DATA_SIZE - 1;
 39e:	83 e0       	ldi	r24, 0x03	; 3
 3a0:	80 93 34 01 	sts	0x0134, r24
 3a4:	5d c0       	rjmp	.+186    	; 0x460 <pirate_process_cmd+0xe4>
			}
			break;
		}

		case MODE_LED_SET_LEVEL: {		// sets PWM rate for the 8 PWM LEDs
			if (comm_data[0] < 4) {
 3a6:	e0 91 30 01 	lds	r30, 0x0130
 3aa:	e4 30       	cpi	r30, 0x04	; 4
 3ac:	20 f4       	brcc	.+8      	; 0x3b6 <pirate_process_cmd+0x3a>
				rgbled_pwm_lf[comm_data[0]] = comm_data[1];
 3ae:	f0 e0       	ldi	r31, 0x00	; 0
 3b0:	ea 5d       	subi	r30, 0xDA	; 218
 3b2:	fe 4f       	sbci	r31, 0xFE	; 254
 3b4:	06 c0       	rjmp	.+12     	; 0x3c2 <pirate_process_cmd+0x46>
			} else if (comm_data[0] < 8) {
 3b6:	e8 30       	cpi	r30, 0x08	; 8
 3b8:	08 f0       	brcs	.+2      	; 0x3bc <pirate_process_cmd+0x40>
 3ba:	51 c0       	rjmp	.+162    	; 0x45e <pirate_process_cmd+0xe2>
				rgbled_pwm_rt[comm_data[0] - 4] = comm_data[1];
 3bc:	f0 e0       	ldi	r31, 0x00	; 0
 3be:	e2 5e       	subi	r30, 0xE2	; 226
 3c0:	fe 4f       	sbci	r31, 0xFE	; 254
 3c2:	80 91 31 01 	lds	r24, 0x0131
 3c6:	80 83       	st	Z, r24
 3c8:	4a c0       	rjmp	.+148    	; 0x45e <pirate_process_cmd+0xe2>
		}
		
		case MODE_TEMPSENSOR_CAL: {
			// to use this function, make sure the temperature has been previously read.
			// calculates the appropriate offset based on the reported temperature.
			if (comm_data_idx >= 1) {
 3ca:	80 91 34 01 	lds	r24, 0x0134
 3ce:	88 23       	and	r24, r24
 3d0:	09 f4       	brne	.+2      	; 0x3d4 <pirate_process_cmd+0x58>
 3d2:	4e c0       	rjmp	.+156    	; 0x470 <pirate_process_cmd+0xf4>
 				// update the offset
				if (adc_result[ADC_CHAN_TEMP]) {
 3d4:	80 91 1e 01 	lds	r24, 0x011E
 3d8:	90 91 1f 01 	lds	r25, 0x011F
 3dc:	89 2b       	or	r24, r25
 3de:	09 f4       	brne	.+2      	; 0x3e2 <pirate_process_cmd+0x66>
 3e0:	42 c0       	rjmp	.+132    	; 0x466 <pirate_process_cmd+0xea>
					temp_offset = adc_result[ADC_CHAN_TEMP] - (int8_t)comm_data[1];
 3e2:	60 91 1e 01 	lds	r22, 0x011E
 3e6:	70 91 1f 01 	lds	r23, 0x011F
 3ea:	80 91 31 01 	lds	r24, 0x0131
 3ee:	68 1b       	sub	r22, r24
 3f0:	71 09       	sbc	r23, r1
 3f2:	87 fd       	sbrc	r24, 7
 3f4:	73 95       	inc	r23
 3f6:	70 93 07 01 	sts	0x0107, r23
 3fa:	60 93 06 01 	sts	0x0106, r22
 					// write it to eeprom
 					eeprom_write_word((uint16_t *)EEPROM_ADDR_TEMPCAL, temp_offset);
 3fe:	8e e3       	ldi	r24, 0x3E	; 62
 400:	90 e0       	ldi	r25, 0x00	; 0
 402:	23 d2       	rcall	.+1094   	; 0x84a <__eewr_word_tn88>
 404:	2c c0       	rjmp	.+88     	; 0x45e <pirate_process_cmd+0xe2>
		}
		
		case MODE_EEPROM_READ: {
			// our data packet is already set; ready for read.
			// but if the host keeps writing...
			if (comm_data_idx > 1) {
 406:	80 91 34 01 	lds	r24, 0x0134
 40a:	82 30       	cpi	r24, 0x02	; 2
 40c:	40 f5       	brcc	.+80     	; 0x45e <pirate_process_cmd+0xe2>
 40e:	30 c0       	rjmp	.+96     	; 0x470 <pirate_process_cmd+0xf4>
		}

		// immediate commands
		case MODE_TEMPSENSOR_READ: {
			// attempt another read
			if (!adc_read_mode) {
 410:	80 91 21 01 	lds	r24, 0x0121
 414:	81 11       	cpse	r24, r1
 416:	24 c0       	rjmp	.+72     	; 0x460 <pirate_process_cmd+0xe4>
				adc_read_mode = 0;
 418:	10 92 21 01 	sts	0x0121, r1
				adc_read_step = 0;
 41c:	e1 2c       	mov	r14, r1
				adc_read_mode = ADC_MODE_TEMPSENSOR;
 41e:	88 e0       	ldi	r24, 0x08	; 8
 420:	0b c0       	rjmp	.+22     	; 0x438 <pirate_process_cmd+0xbc>
			// data will probably be prior data unless the host waits. (need to verify)
			comm_timeout = 0;
			break;
		}
		case MODE_LIGHTSENSOR_READ: {
			if (!adc_read_mode) {
 422:	80 91 21 01 	lds	r24, 0x0121
 426:	81 11       	cpse	r24, r1
 428:	1b c0       	rjmp	.+54     	; 0x460 <pirate_process_cmd+0xe4>
				// set the led and step to first step
				adc_read_mode = 0;
 42a:	10 92 21 01 	sts	0x0121, r1
				adc_read_step = 0;
 42e:	e1 2c       	mov	r14, r1
				rgbled_sensor_read_idx(comm_data[0]);
 430:	80 91 30 01 	lds	r24, 0x0130
 434:	5b df       	rcall	.-330    	; 0x2ec <rgbled_sensor_read_idx>
				adc_read_mode = ADC_MODE_LIGHTSENSOR;
 436:	81 e0       	ldi	r24, 0x01	; 1
 438:	80 93 21 01 	sts	0x0121, r24
 43c:	11 c0       	rjmp	.+34     	; 0x460 <pirate_process_cmd+0xe4>
			break;
		}
		case MODE_SLEEP: {
			// put this bitch to bed.
			// we'll wake up when we get another I2C command.
			pirate_sleep_mode = SLEEP_MODE_PWR_DOWN;
 43e:	84 e0       	ldi	r24, 0x04	; 4
 440:	80 93 09 01 	sts	0x0109, r24
 444:	0c c0       	rjmp	.+24     	; 0x45e <pirate_process_cmd+0xe2>
			comm_cmd = 0;
			comm_timeout = 0;
			break;
		}
		case MODE_LIGHTSENSOR_SENS: { 		// 0x10 0x19 <led 0-3> <sens 1-200>
			if (comm_data_idx >= 1) {
 446:	80 91 34 01 	lds	r24, 0x0134
 44a:	88 23       	and	r24, r24
 44c:	89 f0       	breq	.+34     	; 0x470 <pirate_process_cmd+0xf4>
				if ((comm_data[0] <= 0x03) && (comm_data[1])) {
 44e:	80 91 30 01 	lds	r24, 0x0130
 452:	84 30       	cpi	r24, 0x04	; 4
 454:	20 f4       	brcc	.+8      	; 0x45e <pirate_process_cmd+0xe2>
 456:	60 91 31 01 	lds	r22, 0x0131
 45a:	61 11       	cpse	r22, r1
					rgbled_sensor_sensitivity(comm_data[0], comm_data[1]);
 45c:	3d df       	rcall	.-390    	; 0x2d8 <rgbled_sensor_sensitivity>
				}
				comm_cmd = 0;
 45e:	f1 2c       	mov	r15, r1
				comm_timeout = 0;
 460:	10 92 2b 01 	sts	0x012B, r1
 464:	05 c0       	rjmp	.+10     	; 0x470 <pirate_process_cmd+0xf4>
		}
		
		// invalid commands
		default: {
			// send NAK
			comm_cmd = 0;
 466:	f1 2c       	mov	r15, r1
			comm_timeout = 0;
 468:	10 92 2b 01 	sts	0x012B, r1
			return 1;
 46c:	81 e0       	ldi	r24, 0x01	; 1
 46e:	08 95       	ret
		}
	}
	
	return 0;
 470:	80 e0       	ldi	r24, 0x00	; 0
}
 472:	08 95       	ret

00000474 <pirate_tempsensor_read>:
	temperature = temp_adj;
}

static void pirate_tempsensor_read()
{
	if (adc_read_step == 0) {
 474:	8e 2d       	mov	r24, r14
 476:	e1 10       	cpse	r14, r1
 478:	03 c0       	rjmp	.+6      	; 0x480 <pirate_tempsensor_read+0xc>
		// select temperature channel
		adc_channel(ADC_CHAN_TEMP, ADC_REF_BANDGAP);
 47a:	62 e0       	ldi	r22, 0x02	; 2
 47c:	88 e0       	ldi	r24, 0x08	; 8
 47e:	1c ce       	rjmp	.-968    	; 0xb8 <adc_channel>
	} else if (adc_read_step == 3) {
 480:	83 30       	cpi	r24, 0x03	; 3
 482:	19 f4       	brne	.+6      	; 0x48a <pirate_tempsensor_read+0x16>
		// we've waited 1.5ms so the bandgap voltage should have been set.
		// start conversion after bandgap ref change timeout per datasheet
		adc_start(4, 1);
 484:	61 e0       	ldi	r22, 0x01	; 1
 486:	84 e0       	ldi	r24, 0x04	; 4
 488:	39 ce       	rjmp	.-910    	; 0xfc <adc_start>
	} else if (adc_read_step > 3) {
 48a:	84 30       	cpi	r24, 0x04	; 4
 48c:	c8 f0       	brcs	.+50     	; 0x4c0 <pirate_tempsensor_read+0x4c>
		adc_read_step--;
 48e:	81 50       	subi	r24, 0x01	; 1
 490:	e8 2e       	mov	r14, r24
		if (!adc_busy) {
 492:	80 91 20 01 	lds	r24, 0x0120
 496:	81 11       	cpse	r24, r1
 498:	13 c0       	rjmp	.+38     	; 0x4c0 <pirate_tempsensor_read+0x4c>
			// revert reference to AVCC...per the datasheet only changes to
			// bandgap should take ~1ms but changes back to AVCC seem to
			// take a while to be accurate as well
			adc_channel(ADC_CHAN_GND, ADC_REF_AVCC);
 49a:	61 e0       	ldi	r22, 0x01	; 1
 49c:	8f e0       	ldi	r24, 0x0F	; 15
 49e:	0c de       	rcall	.-1000   	; 0xb8 <adc_channel>
			adc_read_mode = 0;
 4a0:	10 92 21 01 	sts	0x0121, r1
static void pirate_tempsensor_process()
{
	int8_t temp_gain;
	int8_t temp_adj;
	
	temp_adj = adc_result[ADC_CHAN_TEMP] - temp_offset;		// our offset adjusted temperature
 4a4:	80 91 1e 01 	lds	r24, 0x011E
 4a8:	90 91 1f 01 	lds	r25, 0x011F
 4ac:	90 91 06 01 	lds	r25, 0x0106
 4b0:	89 1b       	sub	r24, r25
	temp_gain = temp_adj >> 3;								// our gain adjust amount
 4b2:	98 2f       	mov	r25, r24
 4b4:	95 95       	asr	r25
 4b6:	95 95       	asr	r25
 4b8:	95 95       	asr	r25
 4ba:	89 1b       	sub	r24, r25
	while (temp_gain > 0) {temp_gain--; temp_adj--;};		// correct positive gain
	while (temp_gain < 0) {temp_gain++; temp_adj++;};		// correct negative gain
	
	// save temperature
	temperature = temp_adj;
 4bc:	80 93 08 01 	sts	0x0108, r24
 4c0:	08 95       	ret

000004c2 <i2c_slave_tx.constprop.4>:

/* sending */
static uint8_t i2c_slave_tx(uint8_t byte, uint8_t is_last_byte)
{
	// load data
	TWDR = byte;
 4c2:	80 93 bb 00 	sts	0x00BB, r24
	
	// start sending
	TWCR |= _BV(TWINT);
 4c6:	ec eb       	ldi	r30, 0xBC	; 188
 4c8:	f0 e0       	ldi	r31, 0x00	; 0
 4ca:	80 81       	ld	r24, Z
 4cc:	80 68       	ori	r24, 0x80	; 128
 4ce:	80 83       	st	Z, r24
	
	if (is_last_byte) {
		// this is all the data we have to send; send a nack after this byte
		i2c_disable_slave();	
 4d0:	80 81       	ld	r24, Z
 4d2:	8f 7b       	andi	r24, 0xBF	; 191
 4d4:	80 83       	st	Z, r24
	}
	
	return 0;
}
 4d6:	80 e0       	ldi	r24, 0x00	; 0
 4d8:	08 95       	ret

000004da <pirate_data_send>:

static inline uint8_t pirate_data_send()
{
	uint8_t ret;
	
	switch (comm_cmd) {
 4da:	8f 2d       	mov	r24, r15
 4dc:	88 30       	cpi	r24, 0x08	; 8
 4de:	b9 f0       	breq	.+46     	; 0x50e <pirate_data_send+0x34>
 4e0:	89 30       	cpi	r24, 0x09	; 9
 4e2:	c1 f0       	breq	.+48     	; 0x514 <pirate_data_send+0x3a>
 4e4:	84 30       	cpi	r24, 0x04	; 4
 4e6:	51 f5       	brne	.+84     	; 0x53c <pirate_data_send+0x62>
		case MODE_EEPROM_READ: {
			if (comm_data[0] < 64) {
 4e8:	80 91 30 01 	lds	r24, 0x0130
 4ec:	80 34       	cpi	r24, 0x40	; 64
 4ee:	28 f4       	brcc	.+10     	; 0x4fa <pirate_data_send+0x20>
				i2c_slave_tx(eeprom_read_byte((uint8_t *)(uint16_t)comm_data[0]), 1);
 4f0:	90 e0       	ldi	r25, 0x00	; 0
 4f2:	9f d1       	rcall	.+830    	; 0x832 <__eerd_byte_tn88>
 4f4:	e6 df       	rcall	.-52     	; 0x4c2 <i2c_slave_tx.constprop.4>
				ret = 1;
 4f6:	81 e0       	ldi	r24, 0x01	; 1
 4f8:	06 c0       	rjmp	.+12     	; 0x506 <pirate_data_send+0x2c>
			} else {
				// invalid address...
				i2c_disable_slave();
 4fa:	80 91 bc 00 	lds	r24, 0x00BC
 4fe:	8f 7b       	andi	r24, 0xBF	; 191
 500:	80 93 bc 00 	sts	0x00BC, r24
				ret = 255;
 504:	8f ef       	ldi	r24, 0xFF	; 255
			}
			comm_cmd = 0;
 506:	f1 2c       	mov	r15, r1
			comm_timeout = 0;
 508:	10 92 2b 01 	sts	0x012B, r1
 50c:	08 95       	ret
			return ret;
		}
		
		case MODE_TEMPSENSOR_READ: {
			i2c_slave_tx(temperature, 1);
 50e:	80 91 08 01 	lds	r24, 0x0108
 512:	0e c0       	rjmp	.+28     	; 0x530 <pirate_data_send+0x56>
			comm_cmd = 0;
			comm_timeout = 0;
			return 1;
		}
		case MODE_LIGHTSENSOR_READ: {
			i2c_slave_tx(adc_result[comm_data[0] & 0x03] >> 2, 1);
 514:	e0 91 30 01 	lds	r30, 0x0130
 518:	e3 70       	andi	r30, 0x03	; 3
 51a:	f0 e0       	ldi	r31, 0x00	; 0
 51c:	ee 0f       	add	r30, r30
 51e:	ff 1f       	adc	r31, r31
 520:	e2 5f       	subi	r30, 0xF2	; 242
 522:	fe 4f       	sbci	r31, 0xFE	; 254
 524:	80 81       	ld	r24, Z
 526:	91 81       	ldd	r25, Z+1	; 0x01
 528:	96 95       	lsr	r25
 52a:	87 95       	ror	r24
 52c:	96 95       	lsr	r25
 52e:	87 95       	ror	r24
 530:	c8 df       	rcall	.-112    	; 0x4c2 <i2c_slave_tx.constprop.4>
			comm_cmd = 0;
 532:	f1 2c       	mov	r15, r1
			comm_timeout = 0;
 534:	10 92 2b 01 	sts	0x012B, r1
			return 1;	
 538:	81 e0       	ldi	r24, 0x01	; 1
 53a:	08 95       	ret
		}
		
		default: {
			// nothing active; invalid :(
			i2c_disable_slave();
 53c:	80 91 bc 00 	lds	r24, 0x00BC
 540:	8f 7b       	andi	r24, 0xBF	; 191
 542:	80 93 bc 00 	sts	0x00BC, r24
			return 255;
 546:	8f ef       	ldi	r24, 0xFF	; 255
		}
	}
	
	return 0;
}
 548:	08 95       	ret

0000054a <main>:
/* func */
static void system_init()
{
	// make SURE we are running at 8MHz
	// do this by first enabling clock divider setup mode,
	CLKPR = _BV(CLKPCE);
 54a:	80 e8       	ldi	r24, 0x80	; 128
 54c:	80 93 61 00 	sts	0x0061, r24
	// and disabling any divider
	CLKPR = 0;
 550:	10 92 61 00 	sts	0x0061, r1
}

static void system_io_init()
{
	// enable break-before-make outputs on all IO. SAFETY FIRST
	PORTCR |= (_BV(BBMA) | _BV(BBMB) | _BV(BBMC) | _BV(BBMD));
 554:	82 b3       	in	r24, 0x12	; 18
 556:	80 6f       	ori	r24, 0xF0	; 240
 558:	82 bb       	out	0x12, r24	; 18
	
	// set ALL pins as inputs except PB0
	DDRA = 0x00;
 55a:	1d b8       	out	0x0d, r1	; 13
	DDRB = 0x01;
 55c:	81 e0       	ldi	r24, 0x01	; 1
 55e:	84 b9       	out	0x04, r24	; 4
	DDRC = 0x00;
 560:	17 b8       	out	0x07, r1	; 7
	DDRD = 0x00;
 562:	1a b8       	out	0x0a, r1	; 10
	
	// and enable pullups (this reduces power consumption)
	// in the case of PB0, set it LOW
	PORTA = 0xff;
 564:	cf ef       	ldi	r28, 0xFF	; 255
 566:	ce b9       	out	0x0e, r28	; 14
	PORTB = 0xfe;
 568:	de ef       	ldi	r29, 0xFE	; 254
 56a:	d5 b9       	out	0x05, r29	; 5
	PORTC = 0xff;
 56c:	c8 b9       	out	0x08, r28	; 8
	PORTD = 0xff;
 56e:	cb b9       	out	0x0b, r28	; 11
	
	// configure IO
	system_io_init();
	
	// configure RGBLEDs
	rgbled_io_init();
 570:	39 de       	rcall	.-910    	; 0x1e4 <rgbled_io_init>
/* configuration */
static inline void i2c_slave_init(uint8_t address, uint8_t enable_general_addr)
{
	// set bitrate register, clear prescaler
	// should get us 400KHz (fast mode) max rate
	TWBR = 2;
 572:	22 e0       	ldi	r18, 0x02	; 2
 574:	20 93 b8 00 	sts	0x00B8, r18
	TWSR = ~(_BV(TWPS0) | _BV(TWPS1));
 578:	8c ef       	ldi	r24, 0xFC	; 252
 57a:	80 93 b9 00 	sts	0x00B9, r24
	
	// set slave address and clear address mask
	TWAR = ((address << 1) | (enable_general_addr & 1));
 57e:	86 ee       	ldi	r24, 0xE6	; 230
 580:	80 93 ba 00 	sts	0x00BA, r24
	TWAMR = 0;
 584:	10 92 bd 00 	sts	0x00BD, r1
	
	// enable auto-ack, enable TWI, and enable the TWI interrupt
	TWCR = _BV(TWEA) | _BV(TWEN) | _BV(TWIE);
 588:	85 e4       	ldi	r24, 0x45	; 69
 58a:	80 93 bc 00 	sts	0x00BC, r24

/* implementations */
inline static void timer0_init()
{
	// make sure timer is enabled
	PRR &= ~PRTIM0;
 58e:	80 91 64 00 	lds	r24, 0x0064
 592:	8a 7f       	andi	r24, 0xFA	; 250
 594:	80 93 64 00 	sts	0x0064, r24
	
	// enable timer with prescale divider /64, enable TOP mode
	TCCR0A = _BV(CTC0) | (_BV(CS00) | _BV(CS01) | ~(_BV(CS02)));
 598:	9b ef       	ldi	r25, 0xFB	; 251
 59a:	95 bd       	out	0x25, r25	; 37

	// set TOP level to be 62 to 63 counts; this will result in 2KHz cycle @8MHz
	OCR0A = TIMER0_COMPARE;
 59c:	8d e3       	ldi	r24, 0x3D	; 61
 59e:	87 bd       	out	0x27, r24	; 39
	
	// clear timer
	TCNT0 = 0;
 5a0:	16 bc       	out	0x26, r1	; 38
	
	// and enable OCA interrupt (we don't use overflow interrupt as we are in TOP mode)
	TIMSK0 = _BV(OCIE0A);
 5a2:	20 93 6e 00 	sts	0x006E, r18
#define timer0_set_compare(x)		OCR0A = x

inline static void timer1_init()
{
	// make sure timer is enabled
	PRR &= ~PRTIM1;
 5a6:	80 91 64 00 	lds	r24, 0x0064
 5aa:	8c 7f       	andi	r24, 0xFC	; 252
 5ac:	80 93 64 00 	sts	0x0064, r24
	
	// clear PWM OCx
	OCR1AH = 0xff;		// sets temp register to 0xff
 5b0:	c0 93 89 00 	sts	0x0089, r28
	OCR1AL = 0xff;
 5b4:	c0 93 88 00 	sts	0x0088, r28
	OCR1BL = 0xff;
 5b8:	c0 93 8a 00 	sts	0x008A, r28
	
	// clear timer
	TCNT1H = 0;			// sets temp register to 0
 5bc:	10 92 85 00 	sts	0x0085, r1
	TCNT1L = 0;
 5c0:	10 92 84 00 	sts	0x0084, r1
	
	// enable timer OC1 and OC2 clear on match / set at TOP, set to fast PWM mode 14 (ICR1 compare), prescaler off
	// note: in PWM mode 14, pin PB0 can only be used as an output... =(
	TCCR1A = (_BV(COM1A1)) | (_BV(COM1B1)) | (_BV(WGM11) | ~(_BV(WGM10)));
 5c4:	d0 93 80 00 	sts	0x0080, r29
	TCCR1B = (_BV(WGM12) | _BV(WGM13)) | (_BV(CS10));
 5c8:	89 e1       	ldi	r24, 0x19	; 25
 5ca:	80 93 81 00 	sts	0x0081, r24
	TCCR1C = 0;
 5ce:	10 92 82 00 	sts	0x0082, r1
	
	// store timer1 mode to allow enabling / disabling timer
	timer1_mode = TCCR1A;
 5d2:	80 91 80 00 	lds	r24, 0x0080
 5d6:	80 93 2a 01 	sts	0x012A, r24

	// set ICR compare to result in a PWM rate of 8MHz / 252, or 32256Hz
	// This is 16 PWM updates per timer0 63-count period (16.25 per 62-count period)
	// In practice we don't get the first PWM output, so we get:
	//   15/16 PWM / (x) LEDs = 31.25% max duty for 3 LED, 23.43% max duty for 4 LED
	ICR1L = TIMER1_COMPARE;
 5da:	90 93 86 00 	sts	0x0086, r25
	
	// set OC pins as outputs
	DDRB |= (_BV(DDB2) | _BV(DDB1));
 5de:	84 b1       	in	r24, 0x04	; 4
 5e0:	86 60       	ori	r24, 0x06	; 6
 5e2:	84 b9       	out	0x04, r24	; 4
	
	// disable interrupts
	TIMSK1 = 0;
 5e4:	10 92 6f 00 	sts	0x006F, r1
	timer0_init();
	// configure led pwm timer
	timer1_init();
	
	// initialize adc
	adc_init();
 5e8:	55 dd       	rcall	.-1366   	; 0x94 <adc_init>

static void pirate_tempsensor_calibrate()
{
	// NOTE: CALIBRATION IS SINGLE-POINT TO 0 DEGREES CELCIUS! ICE YOUR PEGLEG, MOTHERFUCKER!
	// is pin PA2 low? (pin 3 on attiny88 - is pulled up - short to pin 5 / ground somewhere)
	if ((PINA & _BV(PINA2)) == 0) {
 5ea:	62 99       	sbic	0x0c, 2	; 12
 5ec:	23 c0       	rjmp	.+70     	; 0x634 <main+0xea>
		// turn on the ADC, wait for it to warm up
		adc_init();
 5ee:	52 dd       	rcall	.-1372   	; 0x94 <adc_init>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 5f0:	2f ef       	ldi	r18, 0xFF	; 255
 5f2:	80 e7       	ldi	r24, 0x70	; 112
 5f4:	92 e0       	ldi	r25, 0x02	; 2
 5f6:	21 50       	subi	r18, 0x01	; 1
 5f8:	80 40       	sbci	r24, 0x00	; 0
 5fa:	90 40       	sbci	r25, 0x00	; 0
 5fc:	e1 f7       	brne	.-8      	; 0x5f6 <main+0xac>
 5fe:	00 c0       	rjmp	.+0      	; 0x600 <main+0xb6>
 600:	00 00       	nop
		_delay_ms(100);
		
		// is the pin still low? not a glitch?
		if ((PINA & _BV(PINA2)) == 0) {
 602:	62 99       	sbic	0x0c, 2	; 12
 604:	17 c0       	rjmp	.+46     	; 0x634 <main+0xea>
			// enable interrupts
			sei();
 606:	78 94       	sei
			// start reading the temp sensor, stall until adc is done
			adc_read_mode = ADC_MODE_TEMPSENSOR;
 608:	88 e0       	ldi	r24, 0x08	; 8
 60a:	80 93 21 01 	sts	0x0121, r24
			pirate_tempsensor_read();
 60e:	32 df       	rcall	.-412    	; 0x474 <pirate_tempsensor_read>
			while (adc_busy);
 610:	80 91 20 01 	lds	r24, 0x0120
 614:	81 11       	cpse	r24, r1
 616:	fc cf       	rjmp	.-8      	; 0x610 <main+0xc6>
			
			// here's our correction factor!
			temp_offset = adc_result[ADC_CHAN_TEMP];
 618:	60 91 1e 01 	lds	r22, 0x011E
 61c:	70 91 1f 01 	lds	r23, 0x011F
 620:	70 93 07 01 	sts	0x0107, r23
 624:	60 93 06 01 	sts	0x0106, r22
			
			// write it to eeprom
			eeprom_write_word((uint16_t *)EEPROM_ADDR_TEMPCAL, temp_offset);
 628:	8e e3       	ldi	r24, 0x3E	; 62
 62a:	90 e0       	ldi	r25, 0x00	; 0
 62c:	0e d1       	rcall	.+540    	; 0x84a <__eewr_word_tn88>
			
			// and that's it - we're done.
			adc_read_mode = 0;
 62e:	10 92 21 01 	sts	0x0121, r1
 632:	0d c0       	rjmp	.+26     	; 0x64e <main+0x104>
			return;
		}
	}
	
	// not saving a value - read the value from eeprom
	temp_offset = eeprom_read_word((uint16_t *)EEPROM_ADDR_TEMPCAL);
 634:	8e e3       	ldi	r24, 0x3E	; 62
 636:	90 e0       	ldi	r25, 0x00	; 0
 638:	04 d1       	rcall	.+520    	; 0x842 <__eerd_word_tn88>
	
	// does it seem invalid?
	if (temp_offset > 560) {
 63a:	81 33       	cpi	r24, 0x31	; 49
 63c:	22 e0       	ldi	r18, 0x02	; 2
 63e:	92 07       	cpc	r25, r18
 640:	14 f0       	brlt	.+4      	; 0x646 <main+0xfc>
		// yeah, this isn't right. load rough value for 0degC from datasheet.
		// but you really should calibrate your chip, you lazy fuck.
		temp_offset = 273;
 642:	81 e1       	ldi	r24, 0x11	; 17
 644:	91 e0       	ldi	r25, 0x01	; 1
 646:	90 93 07 01 	sts	0x0107, r25
 64a:	80 93 06 01 	sts	0x0106, r24
	pirate_tempsensor_calibrate();
	
	// and now we wait.
    while (1) {
		// set sleep mode, then set for idle sleep (CPU off, all peripherals on)
		set_sleep_mode(pirate_sleep_mode);
 64e:	83 b7       	in	r24, 0x33	; 51
 650:	89 7f       	andi	r24, 0xF9	; 249
 652:	90 91 09 01 	lds	r25, 0x0109
 656:	89 2b       	or	r24, r25
 658:	83 bf       	out	0x33, r24	; 51
		pirate_sleep_mode = SLEEP_MODE_IDLE;
 65a:	10 92 09 01 	sts	0x0109, r1
		
		// re-enable interrupts and nap.
		sei();
 65e:	78 94       	sei
		sleep_mode();
 660:	83 b7       	in	r24, 0x33	; 51
 662:	81 60       	ori	r24, 0x01	; 1
 664:	83 bf       	out	0x33, r24	; 51
 666:	88 95       	sleep
 668:	83 b7       	in	r24, 0x33	; 51
 66a:	8e 7f       	andi	r24, 0xFE	; 254
 66c:	83 bf       	out	0x33, r24	; 51
 66e:	ef cf       	rjmp	.-34     	; 0x64e <main+0x104>

00000670 <__vector_12>:
}


/* ISR handlers */
ISR(TIMER0_COMPA_vect)
{		
 670:	1f 92       	push	r1
 672:	0f 92       	push	r0
 674:	0f b6       	in	r0, 0x3f	; 63
 676:	0f 92       	push	r0
 678:	11 24       	eor	r1, r1
 67a:	2f 93       	push	r18
 67c:	3f 93       	push	r19
 67e:	4f 93       	push	r20
 680:	5f 93       	push	r21
 682:	6f 93       	push	r22
 684:	7f 93       	push	r23
 686:	8f 93       	push	r24
 688:	9f 93       	push	r25
 68a:	af 93       	push	r26
 68c:	bf 93       	push	r27
 68e:	ef 93       	push	r30
 690:	ff 93       	push	r31
	 * at the faster speed, this is ~3968 cycles/loop @8MHz.
	 ****/
	
	/* TIMEKEEPING */
	// we only count a total of 10 seconds this way before we loop.
	tim0_milli++;
 692:	80 91 0c 01 	lds	r24, 0x010C
 696:	8f 5f       	subi	r24, 0xFF	; 255
 698:	80 93 0c 01 	sts	0x010C, r24
	if (tim0_milli >= 200) {
 69c:	88 3c       	cpi	r24, 0xC8	; 200
 69e:	58 f0       	brcs	.+22     	; 0x6b6 <__vector_12+0x46>
		tim0_milli = 0;
 6a0:	10 92 0c 01 	sts	0x010C, r1
		tim0_centi++;
 6a4:	80 91 0b 01 	lds	r24, 0x010B
 6a8:	8f 5f       	subi	r24, 0xFF	; 255
 6aa:	80 93 0b 01 	sts	0x010B, r24
		if (tim0_centi >= 100) {
 6ae:	84 36       	cpi	r24, 0x64	; 100
 6b0:	10 f0       	brcs	.+4      	; 0x6b6 <__vector_12+0x46>
			tim0_centi = 0;
 6b2:	10 92 0b 01 	sts	0x010B, r1
		}
	}
	
	// 2khz fix. our timer isn't evenly divisible to get our 2K, so we do this...
	OCR0A = (OCR0A == TIMER0_COMPARE) ? TIMER0_COMPARE + 1 : TIMER0_COMPARE;	
 6b6:	87 b5       	in	r24, 0x27	; 39
 6b8:	8d 33       	cpi	r24, 0x3D	; 61
 6ba:	11 f4       	brne	.+4      	; 0x6c0 <__vector_12+0x50>
 6bc:	8e e3       	ldi	r24, 0x3E	; 62
 6be:	01 c0       	rjmp	.+2      	; 0x6c2 <__vector_12+0x52>
 6c0:	8d e3       	ldi	r24, 0x3D	; 61
 6c2:	87 bd       	out	0x27, r24	; 39
	
	
	/* ADC / LIGHT SENSOR / TEMP SENSOR */
	// main adc handler
	if (adc_read_mode) {
 6c4:	80 91 21 01 	lds	r24, 0x0121
 6c8:	88 23       	and	r24, r24
 6ca:	71 f0       	breq	.+28     	; 0x6e8 <__vector_12+0x78>
		switch (adc_read_mode) {
 6cc:	80 91 21 01 	lds	r24, 0x0121
 6d0:	81 30       	cpi	r24, 0x01	; 1
 6d2:	21 f0       	breq	.+8      	; 0x6dc <__vector_12+0x6c>
 6d4:	88 30       	cpi	r24, 0x08	; 8
 6d6:	19 f4       	brne	.+6      	; 0x6de <__vector_12+0x6e>
			case ADC_MODE_TEMPSENSOR: {
				pirate_tempsensor_read();
 6d8:	cd de       	rcall	.-614    	; 0x474 <pirate_tempsensor_read>
				break;
 6da:	01 c0       	rjmp	.+2      	; 0x6de <__vector_12+0x6e>
			}
			case ADC_MODE_LIGHTSENSOR: {
				rgbled_sensor_read();
 6dc:	0b de       	rcall	.-1002   	; 0x2f4 <rgbled_sensor_read>
				break;	
			}
		}
		
		if (adc_read_step <= 0xfe) {
 6de:	8e 2d       	mov	r24, r14
 6e0:	8f 3f       	cpi	r24, 0xFF	; 255
 6e2:	11 f0       	breq	.+4      	; 0x6e8 <__vector_12+0x78>
			adc_read_step++;
 6e4:	8f 5f       	subi	r24, 0xFF	; 255
 6e6:	e8 2e       	mov	r14, r24
	
	
	/* LEDs */
	// TODO: test common cathode mode
	// figure out next LED to update (order is always RGB(X) repeating)
	if (adc_read_mode != ADC_MODE_LIGHTSENSOR) {
 6e8:	80 91 21 01 	lds	r24, 0x0121
 6ec:	81 30       	cpi	r24, 0x01	; 1
 6ee:	41 f0       	breq	.+16     	; 0x700 <__vector_12+0x90>
		rgbled_idx++;
 6f0:	81 e0       	ldi	r24, 0x01	; 1
 6f2:	8d 0d       	add	r24, r13
#ifdef LED_RGBX_4LED
		rgbled_idx &= 0x03;
#else
		if (rgbled_idx > 2) {
 6f4:	83 30       	cpi	r24, 0x03	; 3
 6f6:	10 f4       	brcc	.+4      	; 0x6fc <__vector_12+0x8c>
	
	/* LEDs */
	// TODO: test common cathode mode
	// figure out next LED to update (order is always RGB(X) repeating)
	if (adc_read_mode != ADC_MODE_LIGHTSENSOR) {
		rgbled_idx++;
 6f8:	d8 2e       	mov	r13, r24
 6fa:	01 c0       	rjmp	.+2      	; 0x6fe <__vector_12+0x8e>
#ifdef LED_RGBX_4LED
		rgbled_idx &= 0x03;
#else
		if (rgbled_idx > 2) {
			rgbled_idx = 0;
 6fc:	d1 2c       	mov	r13, r1
		}
#endif

		// and now update them
		rgbled_update();
 6fe:	7f dd       	rcall	.-1282   	; 0x1fe <rgbled_update>
	}
	
	
	/* COMMAND IO */
	// stop processing the command if it isn't complete in 100ms.
	if (comm_cmd != MODE_NONE) {
 700:	ff 20       	and	r15, r15
 702:	a1 f0       	breq	.+40     	; 0x72c <__vector_12+0xbc>
		if (++comm_timeout >= 50) {
 704:	80 91 2b 01 	lds	r24, 0x012B
 708:	8f 5f       	subi	r24, 0xFF	; 255
 70a:	80 93 2b 01 	sts	0x012B, r24
 70e:	82 33       	cpi	r24, 0x32	; 50
 710:	68 f0       	brcs	.+26     	; 0x72c <__vector_12+0xbc>
			comm_cmd = MODE_NONE;
 712:	f1 2c       	mov	r15, r1
			comm_timeout = 0;
 714:	10 92 2b 01 	sts	0x012B, r1
			i2c_disable_slave();
 718:	80 91 bc 00 	lds	r24, 0x00BC
 71c:	8f 7b       	andi	r24, 0xBF	; 191
 71e:	80 93 bc 00 	sts	0x00BC, r24
			i2c_enable_slave();
 722:	80 91 bc 00 	lds	r24, 0x00BC
 726:	80 64       	ori	r24, 0x40	; 64
 728:	80 93 bc 00 	sts	0x00BC, r24
		}
	}
	
	/* PROFILING */
	// determine how much CPU usage we are consuming
	tim0_profiler = TCNT0;
 72c:	86 b5       	in	r24, 0x26	; 38
 72e:	80 93 0a 01 	sts	0x010A, r24
}
 732:	ff 91       	pop	r31
 734:	ef 91       	pop	r30
 736:	bf 91       	pop	r27
 738:	af 91       	pop	r26
 73a:	9f 91       	pop	r25
 73c:	8f 91       	pop	r24
 73e:	7f 91       	pop	r23
 740:	6f 91       	pop	r22
 742:	5f 91       	pop	r21
 744:	4f 91       	pop	r20
 746:	3f 91       	pop	r19
 748:	2f 91       	pop	r18
 74a:	0f 90       	pop	r0
 74c:	0f be       	out	0x3f, r0	; 63
 74e:	0f 90       	pop	r0
 750:	1f 90       	pop	r1
 752:	18 95       	reti

00000754 <__vector_19>:
#ifndef I2C_INTERRUPT_H_
#define I2C_INTERRUPT_H_


ISR(TWI_vect)
{
 754:	1f 92       	push	r1
 756:	0f 92       	push	r0
 758:	0f b6       	in	r0, 0x3f	; 63
 75a:	0f 92       	push	r0
 75c:	11 24       	eor	r1, r1
 75e:	2f 93       	push	r18
 760:	3f 93       	push	r19
 762:	4f 93       	push	r20
 764:	5f 93       	push	r21
 766:	6f 93       	push	r22
 768:	7f 93       	push	r23
 76a:	8f 93       	push	r24
 76c:	9f 93       	push	r25
 76e:	af 93       	push	r26
 770:	bf 93       	push	r27
 772:	ef 93       	push	r30
 774:	ff 93       	push	r31
	// i2c is low priority - allow it to be interrupted
	// sei();
	
	// figure out wtf to do
	switch (TWSR & 0xf8) {	// TWI state
 776:	80 91 b9 00 	lds	r24, 0x00B9
 77a:	88 7f       	andi	r24, 0xF8	; 248
 77c:	80 3a       	cpi	r24, 0xA0	; 160
 77e:	f1 f1       	breq	.+124    	; 0x7fc <__vector_19+0xa8>
 780:	60 f4       	brcc	.+24     	; 0x79a <__vector_19+0x46>
 782:	88 36       	cpi	r24, 0x68	; 104
 784:	09 f4       	brne	.+2      	; 0x788 <__vector_19+0x34>
 786:	3f c0       	rjmp	.+126    	; 0x806 <__vector_19+0xb2>
 788:	28 f4       	brcc	.+10     	; 0x794 <__vector_19+0x40>
 78a:	88 23       	and	r24, r24
 78c:	91 f1       	breq	.+100    	; 0x7f2 <__vector_19+0x9e>
 78e:	80 36       	cpi	r24, 0x60	; 96
 790:	d1 f1       	breq	.+116    	; 0x806 <__vector_19+0xb2>
 792:	34 c0       	rjmp	.+104    	; 0x7fc <__vector_19+0xa8>
 794:	80 38       	cpi	r24, 0x80	; 128
 796:	39 f0       	breq	.+14     	; 0x7a6 <__vector_19+0x52>
 798:	31 c0       	rjmp	.+98     	; 0x7fc <__vector_19+0xa8>
 79a:	88 3b       	cpi	r24, 0xB8	; 184
 79c:	41 f1       	breq	.+80     	; 0x7ee <__vector_19+0x9a>
 79e:	70 f5       	brcc	.+92     	; 0x7fc <__vector_19+0xa8>
 7a0:	88 3a       	cpi	r24, 0xA8	; 168
 7a2:	29 f1       	breq	.+74     	; 0x7ee <__vector_19+0x9a>
 7a4:	2b c0       	rjmp	.+86     	; 0x7fc <__vector_19+0xa8>
		case 0x78: {
			// unused: this is for genaddr mode.
		}
		*/
		case 0x80: {		// slave data receive w/ACK returned
			if (pirate_process_data(TWDR)) {
 7a6:	80 91 bb 00 	lds	r24, 0x00BB
	return 0;
}

static uint8_t pirate_process_data(uint8_t data)
{
	if (comm_cmd == MODE_NONE) {
 7aa:	f1 10       	cpse	r15, r1
 7ac:	0f c0       	rjmp	.+30     	; 0x7cc <__vector_19+0x78>
		// we aren't processing any commands, so this must be a new command/request.
		// first 4 bits = command
		comm_cmd = data >> 4;
 7ae:	98 2f       	mov	r25, r24
 7b0:	92 95       	swap	r25
 7b2:	9f 70       	andi	r25, 0x0F	; 15
 7b4:	f9 2e       	mov	r15, r25
		// last 4 bits = optional data
		comm_data[0] = data & 0x0f;
 7b6:	98 2f       	mov	r25, r24
 7b8:	9f 70       	andi	r25, 0x0F	; 15
 7ba:	90 93 30 01 	sts	0x0130, r25
	
		// clear our data watchdog and data index
		comm_data_idx = 0;
 7be:	10 92 34 01 	sts	0x0134, r1
		comm_timeout = 0;
 7c2:	10 92 2b 01 	sts	0x012B, r1
	
		// if this is an immediate command, process it
		if (data & 0x80) {
 7c6:	87 ff       	sbrs	r24, 7
 7c8:	1e c0       	rjmp	.+60     	; 0x806 <__vector_19+0xb2>
 7ca:	0a c0       	rjmp	.+20     	; 0x7e0 <__vector_19+0x8c>
			return pirate_process_cmd();
		}
	} else {
		// command in progress - add data and continue
		comm_data_idx++;
 7cc:	e0 91 34 01 	lds	r30, 0x0134
 7d0:	ef 5f       	subi	r30, 0xFF	; 255
		comm_data_idx &= (COMM_DATA_SIZE - 1);		// data will LOOP in case of problems; TODO: NAK on failure
 7d2:	e3 70       	andi	r30, 0x03	; 3
 7d4:	e0 93 34 01 	sts	0x0134, r30
		comm_data[comm_data_idx] = data;
 7d8:	f0 e0       	ldi	r31, 0x00	; 0
 7da:	e0 5d       	subi	r30, 0xD0	; 208
 7dc:	fe 4f       	sbci	r31, 0xFE	; 254
 7de:	80 83       	st	Z, r24
		return pirate_process_cmd();
 7e0:	cd dd       	rcall	.-1126   	; 0x37c <pirate_process_cmd>
 7e2:	88 23       	and	r24, r24
 7e4:	81 f0       	breq	.+32     	; 0x806 <__vector_19+0xb2>
				// I wanted to send a NAK, but TWI already sent an ACK. oh fucking well.
				// send NACK if any further packets are received
				i2c_disable_slave();
 7e6:	80 91 bc 00 	lds	r24, 0x00BC
 7ea:	8f 7b       	andi	r24, 0xBF	; 191
 7ec:	0a c0       	rjmp	.+20     	; 0x802 <__vector_19+0xae>
		}
		case 0xb8: {		// slave read continues, master ACK'd last packet
			// do we have a mode in progress?
			// NOTE: by default, slave tx modes won't unset, but slave mode will be disabled
			//       when the last packet is sent, and re-enabled on the following ACK/NACK.
			pirate_data_send();
 7ee:	75 de       	rcall	.-790    	; 0x4da <pirate_data_send>
			break;
 7f0:	0a c0       	rjmp	.+20     	; 0x806 <__vector_19+0xb2>
		}
		
		// ** ERROR AND UNHANDLED ** //
		case 0x00: {			// bus error
			// set TWSTO, clear TWINT (by setting) as per datasheet
			TWCR |= (_BV(TWSTO)) | (_BV(TWINT));
 7f2:	80 91 bc 00 	lds	r24, 0x00BC
 7f6:	80 69       	ori	r24, 0x90	; 144
 7f8:	80 93 bc 00 	sts	0x00BC, r24
			break;
		}
		default: {
			// something unhandled? fuck it, we want to be a slave.
			// reset everything and start over.
			i2c_enable_slave();
 7fc:	80 91 bc 00 	lds	r24, 0x00BC
 800:	80 64       	ori	r24, 0x40	; 64
 802:	80 93 bc 00 	sts	0x00BC, r24
		}
	}
	
	// done with this TWI bit
	i2c_clear_int_flag();
 806:	80 91 bc 00 	lds	r24, 0x00BC
 80a:	80 68       	ori	r24, 0x80	; 128
 80c:	80 93 bc 00 	sts	0x00BC, r24
}
 810:	ff 91       	pop	r31
 812:	ef 91       	pop	r30
 814:	bf 91       	pop	r27
 816:	af 91       	pop	r26
 818:	9f 91       	pop	r25
 81a:	8f 91       	pop	r24
 81c:	7f 91       	pop	r23
 81e:	6f 91       	pop	r22
 820:	5f 91       	pop	r21
 822:	4f 91       	pop	r20
 824:	3f 91       	pop	r19
 826:	2f 91       	pop	r18
 828:	0f 90       	pop	r0
 82a:	0f be       	out	0x3f, r0	; 63
 82c:	0f 90       	pop	r0
 82e:	1f 90       	pop	r1
 830:	18 95       	reti

00000832 <__eerd_byte_tn88>:
 832:	f9 99       	sbic	0x1f, 1	; 31
 834:	fe cf       	rjmp	.-4      	; 0x832 <__eerd_byte_tn88>
 836:	1f ba       	out	0x1f, r1	; 31
 838:	81 bd       	out	0x21, r24	; 33
 83a:	f8 9a       	sbi	0x1f, 0	; 31
 83c:	99 27       	eor	r25, r25
 83e:	80 b5       	in	r24, 0x20	; 32
 840:	08 95       	ret

00000842 <__eerd_word_tn88>:
 842:	a8 e1       	ldi	r26, 0x18	; 24
 844:	b0 e0       	ldi	r27, 0x00	; 0
 846:	42 e0       	ldi	r20, 0x02	; 2
 848:	05 c0       	rjmp	.+10     	; 0x854 <__eerd_blraw_tn88>

0000084a <__eewr_word_tn88>:
 84a:	11 d0       	rcall	.+34     	; 0x86e <__eewr_byte_tn88>
 84c:	27 2f       	mov	r18, r23
 84e:	10 c0       	rjmp	.+32     	; 0x870 <__eewr_r18_tn88>

00000850 <__eerd_block_tn88>:
 850:	dc 01       	movw	r26, r24
 852:	86 2f       	mov	r24, r22

00000854 <__eerd_blraw_tn88>:
 854:	e8 2f       	mov	r30, r24
 856:	f9 99       	sbic	0x1f, 1	; 31
 858:	fe cf       	rjmp	.-4      	; 0x856 <__eerd_blraw_tn88+0x2>
 85a:	1f ba       	out	0x1f, r1	; 31
 85c:	05 c0       	rjmp	.+10     	; 0x868 <__eerd_blraw_tn88+0x14>
 85e:	e1 bd       	out	0x21, r30	; 33
 860:	f8 9a       	sbi	0x1f, 0	; 31
 862:	e3 95       	inc	r30
 864:	00 b4       	in	r0, 0x20	; 32
 866:	0d 92       	st	X+, r0
 868:	41 50       	subi	r20, 0x01	; 1
 86a:	c8 f7       	brcc	.-14     	; 0x85e <__eerd_blraw_tn88+0xa>
 86c:	08 95       	ret

0000086e <__eewr_byte_tn88>:
 86e:	26 2f       	mov	r18, r22

00000870 <__eewr_r18_tn88>:
 870:	f9 99       	sbic	0x1f, 1	; 31
 872:	fe cf       	rjmp	.-4      	; 0x870 <__eewr_r18_tn88>
 874:	1f ba       	out	0x1f, r1	; 31
 876:	1f ba       	out	0x1f, r1	; 31
 878:	81 bd       	out	0x21, r24	; 33
 87a:	20 bd       	out	0x20, r18	; 32
 87c:	0f b6       	in	r0, 0x3f	; 63
 87e:	f8 94       	cli
 880:	fa 9a       	sbi	0x1f, 2	; 31
 882:	f9 9a       	sbi	0x1f, 1	; 31
 884:	0f be       	out	0x3f, r0	; 63
 886:	01 96       	adiw	r24, 0x01	; 1
 888:	08 95       	ret

0000088a <_exit>:
 88a:	f8 94       	cli

0000088c <__stop_program>:
 88c:	ff cf       	rjmp	.-2      	; 0x88c <__stop_program>
